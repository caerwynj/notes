2025-09-15
Race condition when reading from a closed pipe.
This only seems to occur when we use compiled JIT.

One end of the pipe is written to then closed. 
Is the close happening properly?

The piperead will come along later.  Why does it block on qread if the pipe has been closed?
It should return pipe closed.

There are two threads. The writer and reader. The writer writes
one messages and then closes. When closing and freeing pointers,
there should be no more reference counts for the FD so it should
close the FD.

The reader has another FD.  It is reading one message, then
doing another read. It blocks on that read. There is no more
threads with dis work to do. The other vm thread is idle Sleeping.

Read the devpipe code. Try and break into the function that closes
the FD with the writer exits.  Understand the code around what
happens when there is a read on a closed pipe.

Issue was due to garbage collector.  Some int variables such as nprop
and mutator were being set in assembly as if they were 64bit.

Because of the memory corruption the function calls to freeFD were
never being called.

